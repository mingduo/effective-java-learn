# effective-java-learn
effective java 学习

https://www.jianshu.com/p/fc7b69608954

### 第一章简介
忽略
###  第二章 创建和销毁对象
1. 考虑使用静态工厂方法替代构造方法
2. 当构造方法参数过多时使用builder模式
3. 使用私有构造方法或枚类实现Singleton属性
4. 使用私有构造方法执行非实例化
5. 使用依赖注入取代硬连接资源
6. 避免创建不必要的对象
7. 消除过期的对象引用
8. 避免使用Finalizer和Cleaner机制
9. 使用try-with-resources语句替代try-finally语句
### 第三章 所有对象的通用方法
10. 重写equals方法时遵守通用约定
11. 重写equals方法时同时也要重写hashcode方法
12. 始终重写 toString 方法
13. 谨慎地重写 clone 方法
14.考虑实现Comparable接口
### 第四章 类和接口
15. 使类和成员的可访问性最小化
16. 在公共类中使用访问方法而不是公共属性
17. 最小化可变性
18. 组合优于继承
19. 如果使用继承则设计，并文档说明，否则不该使用
20. 接口优于抽象类
21. 为后代设计接口
22. 接口仅用来定义类型
23. 优先使用类层次而不是标签类
24. 优先考虑静态成员类
25. 将源文件限制为单个顶级类
### 第五章 泛型
26. 不要使用原始类型
27. 消除非检查警告
28. 列表优于数组
29. 优先考虑泛型
30. 优先使用泛型方法
31. 使用限定通配符来增加API的灵活性
32. 合理地结合泛型和可变参数
33. 优先考虑类型安全的异构容器
### 第六章 枚举和注解
34. 使用枚举类型替代整型常量
35. 使用实例属性替代序数
36. 使用EnumSet替代位属性
37. 使用EnumMap替代序数索引
38. 使用接口模拟可扩展的枚举
39. 注解优于命名模式
40. 始终使用Override注解
41. 使用标记接口定义类型
### 第七章 Lambda表达式和Stream流
42. lambda表达式优于匿名类
43. 方法引用优于lambda表达式
44. 优先使用标准的函数式接口
45. 明智审慎地使用Stream
46. 在流中优先使用无副作用的函数
47. 优先使用Collection而不是Stream来作为方法的返回类型
48. 谨慎使用流并行
### 第八章 方法
49. 检查参数有效性
50. 必要时进行防御性拷贝
51. 仔细设计方法签名
52. 明智而审慎地使用重载
53. 明智而审慎地使用可变参数
54. 返回空的数组或集合不要返回null
55. 明智而审慎地返回Optional
56. 为所有已公开的API元素编写文档注释
### 第九章 通用编程
57. 最小化局部变量的作用域
58. for-each循环优于传统for循环
59. 熟悉并使用Java类库
60. 需要精确的结果时避免使用float和double类型
61. 基本类型优于装箱的基本类型
62. 当有其他更合适的类型时就不用字符串
63. 注意字符串连接的性能
64. 通过对象的接口引用对象
65. 接口优于反射
66. 明智谨慎地使用本地方法
67. 明智谨慎地进行优化
68. 遵守普遍接受的命名约定
### 第十章 异常
69. 仅在发生异常的条件下使用异常
70. 对可恢复条件使用已检查异常，对编程错误使用运行时异常
71. 避免不必要地使用检查异常
72. 赞成使用标准异常
73. 抛出合乎于抽象的异常
74. 文档化每个方法抛出的所有异常
75. 在详细信息中包含失败捕获信息
76. 争取保持失败原子性
77. 不要忽略异常
### 第十一章 并发
78. 同步访问共享的可变数据
79. 避免过度同步
80. EXECUTORS, TASKS, STREAMS 优于线程
81. 优先使用并发实用程序替代wait和notify
82. 线程安全文档化
83. 明智谨慎地使用延迟初始化
84. 不要依赖线程调度器
### 第十二章 序列化
85. 其他替代方式优于Java本身序列化
86. 非常谨慎地实现SERIALIZABLE接口
87. 考虑使用自定义序列化形式
88. 防御性地编写READOBJECT方法
89. 对于实例控制，枚举类型优于READRESOLVE
90. 考虑序列化代理替代序列化实例

作者：码匠安徒生
链接：https://www.jianshu.com/p/fc7b69608954
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。